// Based on Exercise 5
module counter

import src/utils/dom

import ref
import string
import test

// import src/utils/test

// type Html[St, Ev] {
//   Element(tag: String, handler: List[EventHandler[St, Ev]], children: List[Html[Ev]], attributes: List[Attribute]);
//   Text(content: String);
// }
record Application[St, Ev](
  update: Ev => Unit / State[St] at {io, global, async},
  view: () => HtmlElement[St, Ev] / State[St] at {io, global, async}
)

record HtmlElement[St, Ev] (
  node: Node,
  tag: String,
  text: String, 
  children: List[HtmlElement[St, Ev]], 
  attributes: List[Attribute],
  handlers: List[EventHandler[Ev]],
  app: Application[St, Ev]
)

record Attribute (
  name: String,
  value: String
)

type EventHandler[Ev] { 
  OnClick(handler: Ev);
  OnChange(handler: (String) => Ev at {});
  OnMouseEnter(handler: Ev);
  OnMouseLeave(handler: Ev)
}

// effect addingChild[St, Ev](child: HtmlElement[St, Ev]): Unit

def button[St, Ev](text: String, children: List[HtmlElement[St, Ev]], attributes: List[Attribute], handlers: List[EventHandler[Ev]], app: Application[St, Ev]) =
  HtmlElement(createElement("button"), "button", text, children, attributes, handlers, app)

def div[St, Ev](text: String, children: List[HtmlElement[St, Ev]], attributes: List[Attribute], handlers: List[EventHandler[Ev]], app: Application[St, Ev]) =
  HtmlElement(createElement("div"), "div", text, children, attributes, handlers, app)

def input[St, Ev](text: String, children: List[HtmlElement[St, Ev]], attributes: List[Attribute], handlers: List[EventHandler[Ev]], app: Application[St, Ev]) =
  HtmlElement(createElement("input"), "input", text, children, attributes, handlers, app)



def appendChild[St, Ev](parent: HtmlElement[St, Ev], child: HtmlElement[St, Ev]): Unit = {
  parent.children.append([child])
  ()
}

def addHandlers[St, Ev](element: HtmlElement[St, Ev], handlers: List[EventHandler[Ev]]): HtmlElement[St, Ev] = {
  val newHandlers = element.handlers.append(handlers)
  val newElement = HtmlElement(element.node, element.tag, element.text, element.children, element.attributes, newHandlers, element.app)
  newElement
}



interface State[St] {
  def getState(): St
  def setState(s: St): Unit
}

/// Handle the `State` effect using a `Ref` (global mutable reference)
def statefully[R, St](r: Ref[St]) { prog: () => R / State[St] }: R =
  try { prog() } with State[St] {
    def getState() = resume(r.get())
    def setState(newState) = { r.set(newState); resume(()) }
  }
