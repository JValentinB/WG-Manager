// Based on Exercise5
module client

import src/utils/dom
import src/utils/UI
import src/database/databaseWeb
import src/database/data
import src/styles
import src/svgIcons

import ref
import string

type Event {
  SwitchSection(section: String);
  ShowAddMenu(section: String);
  HideAddMenu(section: String);

  ShowEditMenu(section: String, entryName: String);
  HideEditMenu(section: String);

  Change(n: Int);
  Reset();
  BorderOn(node: Node);
  BorderOff(node: Node);

  AddTask(name: Node, desc: Node, schedule: Node);
  AddConsumable(name: Node, desc: Node);
  AddFlatmate(input: Node);

  DeleteTask(name: String);
  DeleteConsumable(name: String);
  DeleteFlatmate(name: String);

  UpdateTask(oldName: String, newName: Node, desc: Node, schedule: Node);
  UpdateConsumable(oldName: String, newName: Node, desc: Node);
  UpdateFlatmate(oldName: String, newName: Node);
}

interface Model {
  def switchSection(section: String): Unit
  def showAddMenu(section: String): Unit
  def hideAddMenu(section: String): Unit

  def showEditMenu(section: String, entryName: String): Unit
  def hideEditMenu(section: String): Unit

  def change(n: Int): Unit
  def reset(): Unit
  def count(): Int
  def borderOn(node: Node): Unit
  def borderOff(node: Node): Unit
}
interface DataModel {
  def addTask(name: Node, desc: Node, schedule: Node): Unit
  def addConsumable(name: Node, desc: Node): Unit
  def addFlatmate(input: Node): Unit

  def deleteTask(name: String): Unit
  def deleteConsumable(name: String): Unit
  def deleteFlatmate(name: String): Unit

  def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node): Unit
  def updateConsumable(oldName: String, newName: Node, desc: Node): Unit
  def updateFlatmate(oldName: String, newName: Node): Unit
}

def run[St](root: Node, init: St, app: Application[St, Event]): Unit = app match {
  case Application(update, view) =>
    val inbox = ref[List[Event]](Nil())
    val state = ref(init)

    def send(ev: Event): Unit = inbox.set(Cons(ev, inbox.get))

    def render(html: HtmlElement[St, Event]): Node = {
      var node = html.node
      node = node.innerHTML(html.text) // set the text of the node
      // either run the app or render the children
      html.app match {
        case Some(app) => run(node, state.get, app)
        case None() => html.children.foreach { child => 
          node.appendChild(child.render)
          ()
        }
      }
      html.attributes.foreach { attr => 
        node.setAttribute(attr.name, attr.value)
        ()
      }
      html.handlers.foreach { handler =>
        handler match {
          case OnClick(ev) => {
            node.onClick(box { send(ev) })
          }
          case OnChange(ev) => ()
          case OnMouseEnter(ev) => {
            node.onMouseEnter(box { send(ev) })
          }
          case OnMouseLeave(ev) => node.onMouseLeave(box { send(ev) })
        }
        ()
      }
      node
    }

    // renders the app with the current state
    def render(): Unit = {
      val rendered = statefully(state) { view() }.render
      root.clear;
      root.appendChild(rendered);
      ()
    }

    def loop(deadline: IdleDeadline): Unit = {
      val messages = inbox.get.reverse
      inbox.set(Nil())

      if (messages.nonEmpty) {
        messages.foreach { ev =>
          ev match {
            case AddTask(_, _, _) => {
              statefully(state) { update(ev) }
              render()
            }
            case AddConsumable(_, _) => {
              statefully(state) { update(ev) }
              render()
            }
            case AddFlatmate(_) => {
              statefully(state) { update(ev) }
              render()
            }

            case DeleteTask(_) => {
              statefully(state) { update(ev) }
              render()
            }
            case DeleteConsumable(_) => {
              statefully(state) { update(ev) }
              render()
            }
            case DeleteFlatmate(_) => {
              statefully(state) { update(ev) }
              render()
            }

            case UpdateTask(_, _, _, _) => {
              statefully(state) { update(ev) }
              render()
            }
            case UpdateConsumable(_, _, _) => {
              statefully(state) { update(ev) }
              render()
            }
            case UpdateFlatmate(_, _) => {
              statefully(state) { update(ev) }
              render()
            }

            case _ => statefully(state) { update(ev) }
          }
        }
      }
      requestIdleCallback(box loop)
    }

    render()
    requestIdleCallback(box loop)
}

def dispatch(msg: Event) = {
  msg match {
    case SwitchSection(section) => do switchSection(section)
    case ShowAddMenu(section) => do showAddMenu(section)
    case HideAddMenu(section) => do hideAddMenu(section)

    case ShowEditMenu(section, entryName) => do showEditMenu(section, entryName)
    case HideEditMenu(section) => do hideEditMenu(section)

    case Change(n) => do change(n)
    case Reset() => do reset()
    case BorderOn(node) => do borderOn(node)
    case BorderOff(node) => do borderOff(node)
    case _ => ()
  }
}
def dispatchData(msg: Event) = {
  msg match {
    case AddTask(name, desc, schedule) => do addTask(name, desc, schedule)
    case AddConsumable(name, desc) => do addConsumable(name, desc)
    case AddFlatmate(input) => do addFlatmate(input) 

    case DeleteTask(name) => do deleteTask(name)
    case DeleteConsumable(name) => do deleteConsumable(name)  
    case DeleteFlatmate(name) => do deleteFlatmate(name)

    case UpdateTask(oldName, newName, desc, schedule) => do updateTask(oldName, newName, desc, schedule)
    case UpdateConsumable(oldName, newName, desc) => do updateConsumable(oldName, newName, desc)
    case UpdateFlatmate(oldName, newName) => do updateFlatmate(oldName, newName)
    case _ => ()
  }
}

def mainController[R] { prog: => R / Model }: R / State[Int] =
  try { prog() }
  with Model {
    def switchSection(section: String) = {
      ["tasks", "consumables", "flatmates"].foreach { id =>
        val sectionDiv = getElementById(id ++ "Settings")
        sectionDiv match {
          case Some(node) => {
            node.toggleDisplay(section == id)
          }
          case None() => ()
        }
        val sectionButton = getElementById(id ++ "Button")
        sectionButton match {
          case Some(node) => {
            if (section == id) {
              node.setAttribute("style", stylesNavBar("navButtonActive"))
            } else {
              node.setAttribute("style", stylesNavBar("navButton"))
            }
            ()
          }
          case None() => ()
        }
        ()
      }
      resume(())
    }
    def showAddMenu(section: String) = {
      toggleAddMenu(section, true)
      resume(())
    }
    def hideAddMenu(section: String) = {
      toggleAddMenu(section, false)
      resume(())
    }

    def showEditMenu(section: String, entryName: String) = {
      toggleEditMenu(section, entryName)
      resume(())
    }
    def hideEditMenu(section: String) = {
      toggleEditMenu(section, "")
      resume(())
    }

    def count() = resume(do getState())
    def change(n: Int) = {
      val response = post("/change/" ++ show(n))
      do setState(getCount(response))
      resume(())
    }
    def reset() = {
      val response = post("/reset")
      do setState(getCount(response))
      resume(())
    }
    def borderOn(node: Node) = {
      node.setStyle("outline", "1px solid #287aa6")
      resume(())
    }
    def borderOff(node: Node) = {
      node.setStyle("outline", "none")
      resume(())
    }
}


def runApp(): Unit = {
  // request the database file 
  var database in global = fetchDatabase("/database")
  var flatmates in global = database.getFlatmates()
  var tasks in global = database.getTasks()
  var consumables in global = database.getConsumables()

  def updateDatabase(): Unit = {
    database = fetchDatabase("/database")
  }
  def updateDataCategoryFromDatabase(category: String): Unit = {
    category match {
      case "flatmates" => flatmates = database.getFlatmates()
      case "tasks" => tasks = database.getTasks()
      case "consumables" => consumables = database.getConsumables()
      case _ => ()
    }
  }

  def dataController[R] { prog: => R / DataModel }: R / State[Int] = {
    try { prog() }
    with DataModel {
      def addTask(name: Node, desc: Node, schedule: Node) = {
        val taskName = name.getValue()
        val taskDesc = desc.getValue()
        val taskSchedule = schedule.getValue()
        if (taskName != "" && taskDesc != "" && taskSchedule != "") {
          val response = post("/addTask", "{\"name\":\"" ++ taskName ++ "\",\"description\":\"" ++ taskDesc ++ "\",\"schedule\":" ++ taskSchedule ++ "}")
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
          ()
        }
        resume(())
      }
      def addConsumable(name: Node, desc: Node) = {
        val consumableName = name.getValue()
        val consumableDesc = desc.getValue()
        if (consumableName != "" && consumableDesc != "") {
          val response = post("/addConsumable", "{\"name\":\"" ++ consumableName ++ "\",\"description\":\"" ++ consumableDesc ++ "\"}")
          updateDatabase()
          updateDataCategoryFromDatabase("consumables")
          ()
        }
        resume(())
      }
      def addFlatmate(input: Node) = {
        val name = input.getValue()
        if (name != "") {
          val response = post("/addFlatmate", "{\"name\":\"" ++ name ++ "\"}")
          try {
            checkResponse(response)
          } with ServerMessage {
            def success() = {
              updateDatabase()
              updateDataCategoryFromDatabase("flatmates")   
              resume(())
            }
            def error(msg: String) = {
              consoleError(msg)
              alert(msg)
              resume(())
            }
          }
        }
        resume(())
      }
      def deleteTask(name: String) = {
        val response = post("/deleteTask", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("tasks")
        resume(())
      }
      def deleteConsumable(name: String) = {
        val response = post("/deleteConsumable", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("consumables")
        resume(())
      }
      def deleteFlatmate(name: String) = {
        val response = post("/deleteFlatmate", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("flatmates")
        resume(())
      }

      def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node) = {
        resume(())
      }
      def updateConsumable(oldName: String, newName: Node, desc: Node) = {
        resume(())
      }
      def updateFlatmate(oldName: String, newName: Node) = {
        resume(())
      }
    }
  }


  def viewNavigationBar(): HtmlElement[Int, Event] / Model = {
    val tasksButton = button(svg("tasks"), [], 
      [Attribute("style", stylesNavBar("navButtonActive")), Attribute("id", "tasksButton")], 
      [OnClick(SwitchSection("tasks"))], None()
    )
    val consumButton = button(svg("consumables"), [], 
      [Attribute("style", stylesNavBar("navButton")), Attribute("id", "consumablesButton")], 
      [OnClick(SwitchSection("consumables"))], None()
    )
    val flatmatesButton = button(svg("flatmates"), [], 
      [Attribute("style", stylesNavBar("navButton")), Attribute("id", "flatmatesButton")], 
      [OnClick(SwitchSection("flatmates"))], None()
    )
    val wrapper = div("", [tasksButton, consumButton, flatmatesButton], [Attribute("style", styles("wrapper"))], [], None())

    val navBarApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        ev.dispatch()
      },
      box { 
        with mainController
        wrapper
      }
    )
    val navBar = div("", 
      [], [Attribute("style", stylesNavBar("navBar"))], 
      [], Some(navBarApp))
    navBar
  }
  def viewAddButton(section: String): HtmlElement[Int, Event] / Model = {
    val addButton = button("+", [], 
      [Attribute("style", styles("addButton")), Attribute("id", section ++ "AddButton")], 
      [OnClick(ShowAddMenu(section))], None()
    )
    addButton
  }


  def viewAddTask(): HtmlElement[Int, Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task description")], 
      [], None()
    )
    val numberAttributes = [Attribute("type", "number"), Attribute("min", "1"), Attribute("max", "365")]
    val scheduleInput = input("", [], 
      numberAttributes.append([Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task schedule in days")]), 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddTask(nameInput.node, descriptionInput.node, scheduleInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("tasks"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [nameInput, descriptionInput, scheduleInput, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "tasksAddMenu")],
      [], None()
    )
    container
  }
  def viewAddConsumable(): HtmlElement[Int, Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable description")], 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddConsumable(nameInput.node, descriptionInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("consumables"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [nameInput, descriptionInput, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "consumablesAddMenu")],
      [], None()
    )
    container
  }
  def viewAddFlatmate(): HtmlElement[Int, Event] / { Model, DataModel } = {
    val input = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter flatmate name")], 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddFlatmate(input.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("flatmates"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [input, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "flatmatesAddMenu")],
      [], None()
    )
    container
  }


  def viewEditTask(task: Task): HtmlElement[Int, Event] / { Model, DataModel } = {
    div(task.name, [], [Attribute("style", stylesSection("title"))], [], None())
  }
  def viewEditConsumable(consumable: Consumable): HtmlElement[Int, Event] / { Model, DataModel } = {
    div(consumable.name, [], [Attribute("style", stylesSection("title"))], [], None())
  }
  def viewEditFlatmate(flatmate: Flatmate): HtmlElement[Int, Event] / { Model, DataModel } = {
    val title = div(flatmate.name, [], [Attribute("style", stylesSection("title"))], [], None())
    val textInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter a new name")], 
      [], None()
    )
    val deleteButton = button("Delete", [], 
      [Attribute("style", styles("groupButton"))],
      [OnClick(DeleteFlatmate(flatmate.name))], None()
    )
    // Add a confirm and cancel in a button group
    val confirmButton = button("Confirm", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(UpdateFlatmate(flatmate.name, textInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideEditMenu("flatmate"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    div("", 
      [title, textInput, deleteButton, buttonContainer], 
      [Attribute("style", stylesSection("editMenu")), Attribute("id", flatmate.name ++ "Edit")],
      [], None()
    )
  }


  def viewSingleTask(task: Task): HtmlElement[Int, Event] / { Model, DataModel } = {
    // Create a card for each flatmate assign to the task an put them in a container
    def taskMenu(): HtmlElement[Int, Event] / { Model, DataModel } = {
      val reorderedFlatmates = task.assignedFlatmates.reorderFlatmates(task.nextInTurn)
      var flatmateCards = empty[HtmlElement[Int, Event]]()
      reorderedFlatmates.foreach { name =>
        val flatmate = database.getFlatmateByName(name)
        var scale = 1.0
        if (task.nextInTurn == name) {
          scale = 1.1
        }

        val flatmateCard = div(name, [], [Attribute("style", styleCard(flatmate.color, scale))], [], None())
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val nextTime = nextTimeToBeDone(task)
      val title = div(task.name++ " - Next on " ++ nextTime, [], [Attribute("style", stylesSection("title"))], [], None())
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    val taskApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        taskMenu()
      }
    )
    div("", [], [Attribute("id", task.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], Some(taskApp))
  }
  def viewSingleConsumable(consumable: Consumable): HtmlElement[Int, Event] / { Model, DataModel } = {
    // Create a card for each flatmate assign to the task an put them in a container
    def consumableMenu(): HtmlElement[Int, Event] / { Model, DataModel } = {
      var flatmateCards = empty[HtmlElement[Int, Event]]()
      consumable.assignedFlatmates.foreach { name =>
        val flatmate = database.getFlatmateByName(name)
        var scale = 1.0

        val flatmateCard = div(name, [], [Attribute("style", styleCard(flatmate.color, scale))], [], None())
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val title = div(consumable.name, [], [Attribute("style", stylesSection("title"))], [], None())
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    val consumableApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        consumableMenu()
      }
    )
    div("", [], [Attribute("id", consumable.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], Some(consumableApp))
  }
  def viewSingleFlatmate(flatmate: Flatmate): HtmlElement[Int, Event] / { Model, DataModel } = {
    div(flatmate.name, [], [Attribute("style", styleCard(flatmate.color, 1.0))], [OnClick(ShowEditMenu("flatmate", flatmate.name))], None())
  }


  def viewTasks(): HtmlElement[Int, Event] / { Model, DataModel } = {
    def menu(): HtmlElement[Int, Event] / { Model, DataModel } = {
      var taskMenus = empty[HtmlElement[Int, Event]]()
      tasks.foreach { task =>
          val taskMenu = viewSingleTask(task)
          taskMenus = taskMenus.append([taskMenu])
          ()
      }
      val listContainer = div("", taskMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new task
      val addButton = viewAddButton("tasks")
      val addTaskMenu = viewAddTask()
      val addContainer = div("", [addButton, addTaskMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    
    val taskApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "tasksSettings"), Attribute("style", "display: block")], [], Some(taskApp))
  }
  def viewConsumables(): HtmlElement[Int, Event] / Model = {
    def menu(): HtmlElement[Int, Event] / { Model, DataModel } = {
      var consumableMenus = empty[HtmlElement[Int, Event]]()
      consumables.foreach { consumable =>
          val consumableMenu = viewSingleConsumable(consumable)
          consumableMenus = consumableMenus.append([consumableMenu])
          ()
      }
      val listContainer = div("", consumableMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new consumable
      val addButton = viewAddButton("consumables")
      val addConsumableMenu = viewAddConsumable()
      val addContainer = div("", [addButton, addConsumableMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    val consumableApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "consumablesSettings"), Attribute("style", "display: none;")], [], Some(consumableApp))
  }
  def viewFlatmates(): HtmlElement[Int, Event] / { Model, DataModel } = { 

    def menu(): HtmlElement[Int, Event] / { Model, DataModel } = {
      var cards = empty[HtmlElement[Int, Event]]()
      var editMenus = empty[HtmlElement[Int, Event]]()
      flatmates.foreach { flatmate =>
        val flatmateCard = viewSingleFlatmate(flatmate)
        cards = cards.append([flatmateCard])
        val editFlatmate = viewEditFlatmate(flatmate)
        editMenus = editMenus.append([editFlatmate])
        ()
      }
      val cardsContainer = div("", cards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      val title = div("Flatmates", [], [Attribute("style", stylesSection("title"))], [], None())
      val menuContainer = div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())

      val editContainer = div("", editMenus, [Attribute("style", "display: block; width: 100%;"), Attribute("id", "flatmateEdit")], [], None())

      val addButton = viewAddButton("flatmates")
      val addFlatmateMenu = viewAddFlatmate()
      val addContainer = div("", [addButton, addFlatmateMenu], [Attribute("style", styles("addContainer"))], [], None())

      div("", [menuContainer, editContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }

    val flatmateApp = Application[Int, Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "flatmatesSettings"), Attribute("style", "display: none;")], [], Some(flatmateApp))
  }


  def viewMain(): HtmlElement[Int, Event] / { Model, DataModel } = {
    val navBar = viewNavigationBar()
    val tasksContainer = viewTasks()
    val consumablesContainer = viewConsumables()
    val flatmateContainer = viewFlatmates()
    val container = div("", 
      [navBar, tasksContainer, consumablesContainer, flatmateContainer], 
      [Attribute("style", styles("appContainer"))], [], None()
    )
    container
  }



  documentBody.setAttribute("style", styles("body"))
  val appDiv = getElementById("app").getOrElse { 
    val newDiv = createElement("div").setAttribute("id", "app")
    documentBody.appendChild(newDiv)
  }
  appDiv.setAttribute("style", styles("app"))

  run(appDiv, 0, Application(
    box { (ev) => ()},
    box { 
      with mainController
      with dataController
      viewMain()
    }
  ))
  ()
}

def main() = {
  // Download the sql.js library
  addScriptToBody("https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/sql-wasm.js")

  runApp()
  ()
}