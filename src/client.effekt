// Based on Exercise 5 of the Effekt course
module client

import src/utils/dom
import src/utils/UI
import src/utils/misc
import src/database/databaseWeb
import src/database/data
import src/styles
import src/svgIcons

import ref
import string

type Event {
  UIInteraction(action: Action);
  UIReset();
  SwitchSection(section: String);

  AddTask(name: Node, desc: Node, schedule: Node, lastDone: Node);
  AddConsumable(name: Node, desc: Node);
  AddFlatmate(input: Node);

  DeleteTask(name: String);
  DeleteConsumable(name: String);
  DeleteFlatmate(name: String);

  UpdateTask(oldName: String, newName: Node, desc: Node, schedule: Node, lastDone: Node);
  UpdateConsumable(oldName: String, newName: Node, desc: Node, urgency: Node);
  UpdateFlatmate(oldName: String, newName: Node);

  TaskDone(taskName: String, flatmateName: String);
  TaskAssign(taskName: String, flatmateName: String);
  TaskUnassign(taskName: String, flatmateName: String);

  ConsumableCountIncrement(consumableName: String, flatmateName: String);
  ConsumableAssign(consumableName: String, flatmateName: String);
  ConsumableUnassign(consumableName: String, flatmateName: String);
}

interface Model {
  def uiInteraction(action: Action): Unit
  def uiReset(): Unit
  def switchSection(section: String): Unit
}
interface DataModel {
  def addTask(name: Node, desc: Node, schedule: Node, lastDone: Node): Unit
  def addConsumable(name: Node, desc: Node): Unit
  def addFlatmate(input: Node): Unit

  def deleteTask(name: String): Unit
  def deleteConsumable(name: String): Unit
  def deleteFlatmate(name: String): Unit

  def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node, lastDone: Node): Unit
  def updateConsumable(oldName: String, newName: Node, desc: Node, urgency: Node): Unit
  def updateFlatmate(oldName: String, newName: Node): Unit

  def taskDone(taskName: String, flatmateName: String): Unit
  def taskAssign(taskName: String, flatmateName: String): Unit
  def taskUnassign(taskName: String, flatmateName: String): Unit

  def consumableCountIncrement(consumableName: String, flatmateName: String): Unit
  def consumableAssign(consumableName: String, flatmateName: String): Unit
  def consumableUnassign(consumableName: String, flatmateName: String): Unit
}

def dispatch(msg: Event) = {
  msg match {
    case UIInteraction(action) => do uiInteraction(action)
    case UIReset() => do uiReset()
    case SwitchSection(section) => do switchSection(section)
    case _ => ()
  }
}
def dispatchData(msg: Event) = {
  msg match {
    case AddTask(name, desc, schedule, lastDone) => do addTask(name, desc, schedule, lastDone)
    case AddConsumable(name, desc) => do addConsumable(name, desc)
    case AddFlatmate(input) => do addFlatmate(input) 

    case DeleteTask(name) => do deleteTask(name)
    case DeleteConsumable(name) => do deleteConsumable(name)  
    case DeleteFlatmate(name) => do deleteFlatmate(name)

    case UpdateTask(oldName, newName, desc, schedule, lastDone) => do updateTask(oldName, newName, desc, schedule, lastDone)
    case UpdateConsumable(oldName, newName, desc, urgency) => do updateConsumable(oldName, newName, desc, urgency)
    case UpdateFlatmate(oldName, newName) => do updateFlatmate(oldName, newName)

    case TaskDone(taskName, flatmateName) => do taskDone(taskName, flatmateName)
    case TaskAssign(taskName, flatmateName) => do taskAssign(taskName, flatmateName)
    case TaskUnassign(taskName, flatmateName) => do taskUnassign(taskName, flatmateName)

    case ConsumableCountIncrement(consumableName, flatmateName) => do consumableCountIncrement(consumableName, flatmateName)
    case ConsumableAssign(consumableName, flatmateName) => do consumableAssign(consumableName, flatmateName)
    case ConsumableUnassign(consumableName, flatmateName) => do consumableUnassign(consumableName, flatmateName)
    case _ => ()
  }
}

def run(root: Node, app: Application[Event]): Unit = app match {
  case Application(update, view) =>
    val inbox = ref[List[Event]](Nil())

    def send(ev: Event): Unit = inbox.set(Cons(ev, inbox.get))

    def render(html: HtmlElement[Event]): Node = {
      var node = html.node
      node = node.innerHTML(html.text) // set the text of the node
      // either run the app or render the children
      html.app match {
        case Some(app) => run(node, app)
        case None() => html.children.foreach { child => 
          node.appendChild(child.render)
          ()
        }
      }
      html.attributes.foreach { attr => 
        node.setAttribute(attr.name, attr.value)
        ()
      }
      html.handlers.foreach { handler =>
        handler match {
          case OnClick(ev) => {
            node.onClick(box { send(ev) })
          }
          case OnChange(ev) =>{
            node.onChange(box { send(ev) })
          }
          case OnMouseEnter(ev) => {
            node.onMouseEnter(box { send(ev) })
          }
          case OnMouseLeave(ev) => node.onMouseLeave(box { send(ev) })
        }
        ()
      }
      node
    }

    // renders the app with the current state
    def render(): Unit = {
      val rendered = view().render
      root.clear;
      root.appendChild(rendered);
      ()
    }

    def loop(deadline: IdleDeadline): Unit = {
      val messages = inbox.get.reverse
      inbox.set(Nil())

      if (messages.nonEmpty) {
        messages.foreach { ev =>
          update(ev)
          ev match {
            case AddTask(_, _, _, _) => render()
            case AddConsumable(_, _) => render()
            case AddFlatmate(_) => render()

            case DeleteTask(_) => render()
            case DeleteConsumable(_) => render()
            case DeleteFlatmate(_) => render()

            case UpdateTask(_, _, _, _, _) => render()
            case UpdateConsumable(_, _, _, _) => render()
            case UpdateFlatmate(_, _) => render()

            case TaskDone(_, _) => render()
            case TaskAssign(_, _) => render()
            case TaskUnassign(_, _) => render()

            case ConsumableCountIncrement(_, _) => render()
            case ConsumableAssign(_, _) => render()
            case ConsumableUnassign(_, _) => render()

            case UIReset() => render()

            case _ => ()
          }
        }
      }
      requestIdleCallback(box loop)
    }

    render()
    requestIdleCallback(box loop)
}

def runApp(): Unit = {
  // request the WG Manager data
  var database in global = fetchDatabase("/database")
  var flatmates in global = database.getFlatmates()
  var tasks in global = database.getTasks()
  var consumables in global = database.getConsumables()

  def updateDatabase(): Unit = {
    database = fetchDatabase("/database")
  }
  def updateDataCategoryFromDatabase(category: String): Unit = {
    category match {
      case "flatmates" => flatmates = database.getFlatmates()
      case "tasks" => tasks = database.getTasks()
      case "consumables" => consumables = database.getConsumables()
      case _ => ()
    }
  }


  def mainController[R] { prog: => R / Model }: R = {
    try { prog() }
    with Model {
      def uiInteraction(action: Action) = action match {
        case Action(f) => {
          f()
          resume(())
        }
      }
      def uiReset() = {
        // simply resets the application
        resume(())
      }

      def switchSection(section: String) = {
        ["tasks", "consumables", "flatmates"].foreach { id =>
          getElementById(id ++ "Settings").foreach { node =>
            node.toggleDisplay(section == id)
          }

          getElementById(id ++ "Button").foreach { node =>
            if (section == id) {
              node.setAttribute("style", stylesNavBar("navButtonActive"))
            } else {
              node.setAttribute("style", stylesNavBar("navButtonInactive"))
            }
            ()
          }
          ()
        }
        resume(())
      }
    }
  }
  def dataController[R] { prog: => R / DataModel }: R = {
    try { prog() }
    with DataModel {
      def addTask(name: Node, desc: Node, schedule: Node, lastDone: Node) = {
        val taskName = name.getValue()
        val taskDesc = desc.getValue()
        val taskSchedule = schedule.getValue()
        val taskLastDone = lastDone.getValue().datestringToTimestamp()

        if (taskName == "" || taskSchedule == "") {
          alert("Please enter a name and schedule")
        } else if (taskName.contains(",")) {
          alert("Task name cannot contain a comma.")
        } else {
          val response = post(
            "/addTask", 
            "{\"name\":\"" ++ taskName ++ "\",\"description\":\"" ++ taskDesc ++ "\",\"schedule\":" ++ taskSchedule ++ ",\"lastDone\":" ++ show(taskLastDone) ++ "}"
          )
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("tasks")
          }
        }
        resume(())
      }
      def addConsumable(name: Node, desc: Node) = {
        val consumableName = name.getValue()
        val consumableDesc = desc.getValue()
        if (consumableName == "") {
          alert("Please enter a name.")
        } else if (consumableName.contains(",")) {
          alert("Consumable name cannot contain a comma.")
        } else {
          val response = post("/addConsumable", "{\"name\":\"" ++ consumableName ++ "\",\"description\":\"" ++ consumableDesc ++ "\"}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("consumables")
          }
        }
        resume(())
      }
      def addFlatmate(input: Node) = {
        val name = input.getValue()
        if (name == "") {
          alert("Please enter a name")
        } else if (name.contains(",")) {
          alert("Flatmate name cannot contain a comma.")
        } else {
          val response = post("/addFlatmate", "{\"name\":\"" ++ name ++ "\"}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("flatmates")
          }
        }
        resume(())
      }
      def deleteTask(name: String) = {
        val response = post("/deleteTask", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("tasks")
        resume(())
      }
      def deleteConsumable(name: String) = {
        val response = post("/deleteConsumable", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("consumables")
        resume(())
      }
      def deleteFlatmate(name: String) = {
        val response = post("/deleteFlatmate", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("flatmates")
        resume(())
      }

      def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node, lastDone: Node) = {
        val name = newName.getValue()
        val description = desc.getValue().escapeJsonString()
        val schedule = schedule.getValue()
        val lastDone = lastDone.getValue().datestringToTimestamp()

        if (name == "" || schedule == "") {
          alert("Please enter a name and schedule.")
        } else if (name.contains(",")) {
          alert("Task name cannot contain a comma.")
        } else {
          var response = ""
          if (oldName == name) {
            response = post(
              "/updateTask", 
              "{\"name\":\"" ++ name ++ "\",\"description\":\"" ++ description ++ "\",\"schedule\":" ++ schedule ++ ",\"lastDone\":" ++ show(lastDone) ++ "}"
            )
          } else {
            response = post(
              "/renameTask", 
              "{\"oldName\":\"" ++ oldName ++ "\",\"newName\":\"" ++ name ++ "\",\"description\":\"" ++ description ++ "\",\"schedule\":" ++ schedule ++ ",\"lastDone\":" ++ show(lastDone) ++ "}"
            )
          }

          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("tasks")
          }
        }
        resume(())
      }
      def updateConsumable(oldName: String, newName: Node, desc: Node, urgency: Node) = {
        val name = newName.getValue()
        val description = desc.getValue().escapeJsonString()
        val urgencyValue = urgency.getAttribute("data-value")

        consoleLog(urgencyValue)
        if (name == "") {
          alert("Please enter a name.")
        } else if (name.contains(",")) {
          alert("Consumable name cannot contain a comma.")
        } else {
          var response = ""
          if (oldName == name) {
            response = post("/updateConsumable", "{\"name\":\"" ++ name ++ "\",\"description\":\"" ++ description ++ "\",\"urgency\":" ++ urgencyValue ++ "}")
          } else {
            response = post("/renameConsumable", "{\"oldName\":\"" ++ oldName ++ "\",\"newName\":\"" ++ name ++ "\",\"description\":\"" ++ description ++ "\",\"urgency\":" ++ urgencyValue ++ "}")
          }

          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("consumables")
          }
        }
        resume(())
      }
      def updateFlatmate(oldName: String, newName: Node) = {
        val name = newName.getValue()
        
        if (name == "") {
          alert("Please enter a name")
        } else if (name.contains(",")) {
          alert("Flatmate name cannot contain a comma.")
        } else {
          var color = ""
          getElementById(oldName ++ "Card").foreach { card => 
            card.setAttribute("id", name ++ "Card")

            color = card.getAttribute("data-value")
            ()
          }
          
          var response = ""
          if (oldName == name) {
            response = post("/updateFlatmate", "{\"name\":\"" ++ name ++ "\",\"color\":\"" ++ color ++ "\"}")
          } else {
            response = post("/renameFlatmate", "{\"oldName\":\"" ++ oldName ++ "\",\"newName\":\"" ++ name ++ "\",\"color\":\"" ++ color ++ "\"}")
          }

          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("flatmates")
          }
        }
        resume(())
      }

      def taskDone(taskName: String, flatmateName: String) = {
        val response = post("/taskDone", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }
      def taskAssign(taskName: String, flatmateName: String) = {
        val response = post("/taskAssign", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }
      def taskUnassign(taskName: String, flatmateName: String) = {
        val response = post("/taskUnassign", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }

      def consumableCountIncrement(consumableName: String, flatmateName: String) = {
        val response = post("/consumableCountIncrement", "{\"consumableName\":\"" ++ consumableName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("consumables")
        }
        resume(())
      }
      def consumableAssign(consumableName: String, flatmateName: String) = {
        val response = post("/consumableAssign", "{\"consumableName\":\"" ++ consumableName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("consumables")
        }
        resume(())
      }
      def consumableUnassign(consumableName: String, flatmateName: String) = {
        val response = post("/consumableUnassign", "{\"consumableName\":\"" ++ consumableName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("consumables")
        }
        resume(())
      }
    }
  }



  def viewNavigationBar(): HtmlElement[Event] / Model = {

    val tasksButton = button(svg("tasks"), [], 
      [Attribute("style", stylesNavBar("navButtonActive")), Attribute("id", "tasksButton")], 
      [OnClick(SwitchSection("tasks"))], None()
    )
    val consumButton = button(svg("consumables"), [], 
      [Attribute("style", stylesNavBar("navButtonInactive")), Attribute("id", "consumablesButton")], 
      [OnClick(SwitchSection("consumables"))], None()
    )
    val flatmatesButton = button(svg("flatmates"), [], 
      [Attribute("style", stylesNavBar("navButtonInactive")), Attribute("id", "flatmatesButton")], 
      [OnClick(SwitchSection("flatmates"))], None()
    )
    val wrapper = div("", [tasksButton, consumButton, flatmatesButton], [Attribute("style", styles("wrapper"))], [], None())

    val navBarApp = Application[Event](
      box { (ev) => 
        with mainController
        ev.dispatch()
      },
      box { 
        with mainController
        wrapper
      }
    )
    val navBar = div("", 
      [], [Attribute("style", stylesNavBar("navBar"))], 
      [], Some(navBarApp))
    navBar
  }
  def viewAddButton(section: String): HtmlElement[Event] / Model = {
    val plus = div("+", [], [Attribute("style", "position: absolute; top: -25%; left: 46.25%;")], [], None())
    val addButton = button("", [plus], 
      [Attribute("style", styles("addButton")), Attribute("id", section ++ "AddButton")], 
      [], None()
    )
    addButton
  }
  def viewDeleteButton(deleteEvent: Event): HtmlElement[Event] / Model = {
    var deleteButton = button("Delete", [], 
      [Attribute("style", stylesInfos("infoButton"))], 
      [], None()
    )
    val deleteConfirmButton = button("Confirm Delete", [], 
      [Attribute("style", stylesInfos("infoButton"))], 
      [OnClick(deleteEvent)], None()
    )
    var deleteCancelButton = button("Cancel", [], 
      [Attribute("style", stylesInfos("infoButton"))], 
      [], None()
    )
    var deleteWrapper = div("", [], 
      [Attribute("style", stylesInfos("infoWrapper") ++ "display: none; background: rgb(246, 68, 45);")], 
      [], None()
    )
    
    val deleteButtonNode = deleteButton.node
    val deleteCancelNode = deleteCancelButton.node
    val wrapperNode = deleteWrapper.node
    val onDeleteClick = Action(box {
      deleteButtonNode.setStyle("display", "none")
      wrapperNode.setStyle("display", "flex")
      ()
    })
    val onDeleteCancel = Action(box {
      deleteButtonNode.setStyle("display", "block")
      wrapperNode.setStyle("display", "none")
      ()
    })

    deleteButton = deleteButton.addHandlers([OnClick(UIInteraction(onDeleteClick))])
    deleteCancelButton = deleteCancelButton.addHandlers([OnClick(UIInteraction(onDeleteCancel))])
    deleteWrapper = deleteWrapper.appendChildren([deleteConfirmButton, deleteCancelButton])
    div("", [deleteButton, deleteWrapper], [Attribute("style", styles("wrapper") ++ "border-top: 5px solid #ccc;")], [], None())
  }

  def viewTutorial(text: String): HtmlElement[Event] / Model = {
    var showTutorialButton = button(svg("tutorial"), [], 
      [Attribute("style", stylesTutorial("tutorialButton"))], 
      [], None()
    )
    var tutorialText = div(text, [],
      [Attribute("style", stylesTutorial("tutorialText"))], 
      [], None()
    )

    val showTutorialButtonNode = showTutorialButton.node
    val tutorialTextNode = tutorialText.node
    val onTutorialClick = Action(box {
      showTutorialButtonNode.setStyle("display", "none")
      tutorialTextNode.setStyle("display", "block")
      ()
    })
    val onTutorialCancel = Action(box {
      showTutorialButtonNode.setStyle("display", "flex")
      tutorialTextNode.setStyle("display", "none")
      ()
    })

    showTutorialButton = showTutorialButton.addHandlers([OnClick(UIInteraction(onTutorialClick))])
    tutorialText = tutorialText.addHandlers([OnClick(UIInteraction(onTutorialCancel))])
    
    div("", [showTutorialButton, tutorialText], [Attribute("style", stylesTutorial("tutorialContainer"))], [], None())
  }


  def viewAddTask(): HtmlElement[Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task description")], 
      [], None()
    )
    val numberAttributes = [Attribute("type", "number"), Attribute("min", "1"), Attribute("max", "365")]
    val scheduleInput = input("", [], 
      numberAttributes.append([Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task schedule in days")]), 
      [], None()
    )

    // date input
    val currentDate = getCurrentTimeWeb().timestampToDatestring()
    val lastDoneSpan = div("Last done on:", [], 
      [Attribute("style", stylesInfos("infoSpan") ++ "height: 100px; color: #757575; padding: 0;")], 
      [], None()
    )
    val lastDoneInput = input("", [],
      [Attribute("style", styles("textInput") ++ "flex: 1; padding: 0;"), Attribute("value", currentDate), Attribute("type", "date")],
      [], None()
    )
    val lastDoneWrapper = div("", [lastDoneSpan, lastDoneInput], 
      [Attribute("style", stylesInfos("infoWrapper") ++ "width: auto; margin-top: 10px; padding-left: 5%; padding-right: 5%;")], 
      [], None()
    )

    val inputContainer = div("", [nameInput, descriptionInput, scheduleInput, lastDoneWrapper], [Attribute("style", styles("textInputContainer"))], [], None())

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddTask(nameInput.node, descriptionInput.node, scheduleInput.node, lastDoneInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(UIReset())], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [inputContainer, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "tasksAddMenu")],
      [], None()
    )
    container
  }
  def viewAddConsumable(): HtmlElement[Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable description")], 
      [], None()
    )
    val inputContainer = div("", [nameInput, descriptionInput], [Attribute("style", styles("textInputContainer"))], [], None())

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddConsumable(nameInput.node, descriptionInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(UIReset())], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [inputContainer, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "consumablesAddMenu")],
      [], None()
    )
    container
  }
  def viewAddFlatmate(): HtmlElement[Event] / { Model, DataModel } = {
    val input = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter flatmate name")], 
      [], None()
    )
    val inputContainer = div("", [input], [Attribute("style", styles("textInputContainer"))], [], None())

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddFlatmate(input.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(UIReset())], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [inputContainer, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "flatmatesAddMenu")],
      [], None()
    )
    container
  }

  def viewTaskInfos(task: Task): HtmlElement[Event] / { Model, DataModel } = {
    // Task Name
    val infoName = input("", [], 
      [Attribute("style", stylesInfos("infoText")), Attribute("value", task.name)], 
      [], None())
    // Task Description
    val infoDesc = textarea(task.description, [], 
      [Attribute("style", stylesInfos("infoTextArea")), Attribute("value", task.description), Attribute("spellcheck", "false")], 
      [], None())

    // Task Schedule
    val scheduleSpan = div("Schedule:", [], [Attribute("style", stylesInfos("infoSpan"))], [], None())
    val infoSchedule = input("", [], 
      [Attribute("style", stylesInfos("infoText")), Attribute("value", show(task.schedule)), 
        Attribute("type", "number"), Attribute("min", "1"), Attribute("max", "365")], 
      [], None())
    val daysSpan = div("Days", [], [Attribute("style", stylesInfos("infoSpan"))], [], None())
    val scheduleWrapper = div("", [scheduleSpan, infoSchedule, daysSpan], [Attribute("style", stylesInfos("infoWrapper") ++ "margin-top: 10px;")], [], None())

    // Task Last Done
    val lastDoneDate = task.lastDone.timestampToDatestring()
    val lastDoneSpan = div("Last done:", [], [Attribute("style", stylesInfos("infoSpan"))], [], None())
    val infoLastDone = input("", [], 
      [Attribute("style", stylesInfos("infoText") ++ "flex: 2;"), Attribute("value", lastDoneDate), 
        Attribute("type", "date")], 
      [], None())
    val lastDoneWrapper = div("", [lastDoneSpan, infoLastDone], [Attribute("style", stylesInfos("infoWrapper") ++ "margin-top: 10px;")], [], None())

    // Delete Task Button
    val deleteButton = viewDeleteButton(DeleteTask(task.name))
    // Save Button
    val saveButton = button("Save", [], 
      [Attribute("style", stylesInfos("infoButton") ++ "border-top: 5px solid #ccc;")], 
      [OnClick(UpdateTask(task.name, infoName.node, infoDesc.node, infoSchedule.node, infoLastDone.node))], None()
    )

    div("", [infoName, infoDesc, scheduleWrapper, lastDoneWrapper, deleteButton, saveButton], [Attribute("style", stylesInfos("infoContainer"))], [], None())
  }
  def viewConsumableInfos(consumable: Consumable): HtmlElement[Event] / { Model, DataModel } = {
    // Consumable Name
    val infoName = input("", [], 
      [Attribute("style", stylesInfos("infoText")), Attribute("value", consumable.name)], 
      [], None())
    // Consumable Description
    val infoDesc = textarea(consumable.description, [], 
      [Attribute("style", stylesInfos("infoTextArea")), Attribute("value", consumable.description), Attribute("spellcheck", "false")], 
      [], None())

    // Consumable Urgency
    var notUrgentStyle = "border-radius: 15px;"
    var urgentStyle = "border-radius: 15px;"
    var veryUrgentStyle = "border-radius: 15px;"
    if (consumable.urgency == 0) {
      notUrgentStyle = notUrgentStyle ++ "background-color: #ccc;"
    } else if (consumable.urgency == 1) {
      urgentStyle = urgentStyle ++ "background-color: #ccc;"
    } else if (consumable.urgency == 2) {
      veryUrgentStyle = veryUrgentStyle ++ "background-color: #ccc;"
    }

    var notUrgentButton = button("Not Urgent", [], 
      [Attribute("style", stylesInfos("infoButton") ++ notUrgentStyle)], 
      [], None())
    var urgentButton = button("Urgent", [], 
      [Attribute("style", stylesInfos("infoButton") ++ urgentStyle)], 
      [], None())
    var veryUrgentButton = button("Very Urgent", [], 
      [Attribute("style", stylesInfos("infoButton") ++ veryUrgentStyle)], 
      [], None()) 
    var urgencyWrapper = div("", [], 
      [Attribute("style", stylesInfos("infoWrapper") ++ "margin-bottom: 10px;"), Attribute("data-value", show(consumable.urgency))], 
      [], None()
    )

    val notUrgentNode = notUrgentButton.node
    val urgentNode = urgentButton.node
    val veryUrgentNode = veryUrgentButton.node
    val wrapperNode = urgencyWrapper.node
    val onNotUrgent = Action(box {
      notUrgentNode.setStyle("background-color", "#ccc")
      urgentNode.setStyle("background-color", "transparent")
      veryUrgentNode.setStyle("background-color", "transparent")
      wrapperNode.setAttribute("data-value", "0")
      ()
    })
    val onUrgent = Action(box {
      notUrgentNode.setStyle("background-color", "transparent")
      urgentNode.setStyle("background-color", "#ccc")
      veryUrgentNode.setStyle("background-color", "transparent")
      wrapperNode.setAttribute("data-value", "1")
      ()
    })
    val onVeryUrgent = Action(box {
      notUrgentNode.setStyle("background-color", "transparent")
      urgentNode.setStyle("background-color", "transparent")
      veryUrgentNode.setStyle("background-color", "#ccc")
      wrapperNode.setAttribute("data-value", "2")
      ()
    })
    notUrgentButton = notUrgentButton.addHandlers([OnClick(UIInteraction(onNotUrgent))])
    urgentButton = urgentButton.addHandlers([OnClick(UIInteraction(onUrgent))])
    veryUrgentButton = veryUrgentButton.addHandlers([OnClick(UIInteraction(onVeryUrgent))])
    urgencyWrapper = urgencyWrapper.appendChildren([notUrgentButton, urgentButton, veryUrgentButton])

    // Delete Consumable Button
    val deleteButton = viewDeleteButton(DeleteConsumable(consumable.name))

    // Save Button
    val saveButton = button("Save", [], 
      [Attribute("style", stylesInfos("infoButton") ++ "border-top: 5px solid #ccc;")], 
      [OnClick(UpdateConsumable(consumable.name, infoName.node, infoDesc.node, urgencyWrapper.node))], None()
    )

    div("", [infoName, infoDesc, urgencyWrapper, deleteButton, saveButton], [Attribute("style", stylesInfos("infoContainer"))], [], None())
  }
  def viewInfos(infoContainer: HtmlElement[Event]): HtmlElement[Event] / { Model, DataModel } = {
    var showInfosButton = button(svg("arrowdown"), [], 
      [Attribute("style", stylesInfos("infoButton"))], 
      [], None()
    )
    var hideInfosButton = button(svg("arrowup"), [], 
      [Attribute("style", stylesInfos("infoButton") ++ "display: none;")], 
      [], None()
    )

    val showInfosNode = showInfosButton.node
    val hideInfosNode = hideInfosButton.node
    val onShowInfos = Action(box {
      showInfosNode.setStyle("display", "none")
      hideInfosNode.setStyle("display", "block")
      infoContainer.node.setStyle("display", "flex")
      ()
    })
    val onHideInfos = Action(box {
      showInfosNode.setStyle("display", "block")
      hideInfosNode.setStyle("display", "none")
      infoContainer.node.setStyle("display", "none")
      ()
    })

    showInfosButton = showInfosButton.addHandlers([OnClick(UIInteraction(onShowInfos))])
    hideInfosButton = hideInfosButton.addHandlers([OnClick(UIInteraction(onHideInfos))])

    val wrapper = div("", [showInfosButton, infoContainer, hideInfosButton], [Attribute("style", styles("wrapper"))], [], None())
    wrapper 
  }

  def viewSingleTask(task: Task): HtmlElement[Event] / { Model, DataModel } = {
    def assignedFlatmateCard(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
      val taskDoneButton = button("Task Done", [], 
        [Attribute("style", stylesCardMenu("cardButton"))], 
        [OnClick(TaskDone(task.name, flatmate.name))], None()
      )
      val topGroup = div("", [taskDoneButton], [Attribute("style", styles("buttonGroup") ++ "top: 0;")], [], None())
      val topGroupParent = div("", [topGroup], [Attribute("style", stylesCardMenu("topButtonGroup"))], [], None())

      val unassignButton = button("Unassign", [], 
        [Attribute("style", stylesCardMenu("cardButton"))], 
        [OnClick(TaskUnassign(task.name, flatmate.name))], None()
      )
      val bottomGroup = div("", [unassignButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -15px;")], [], None())
      val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesCardMenu("bottomButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        topGroupParent.node.setStyle("top", "-100px")
        bottomGroupParent.node.setStyle("bottom", "-100px")
        ()
      })
      div(flatmate.name, [topGroupParent, bottomGroupParent], 
        [Attribute("style", styleCard(flatmate.color))], 
        [OnClick(UIInteraction(onShowEditMenu))], None()
      )
    }
    def unassignedFlatmateCard(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
      val assignButton = button("Assign", [], 
        [Attribute("style", stylesCardMenu("cardButton"))], 
        [OnClick(TaskAssign(task.name, flatmate.name))], None()
      )
      val bottomGroup = div("", [assignButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -15px;")], [], None())
      val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesCardMenu("bottomButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        bottomGroupParent.node.setStyle("bottom", "-100px")
        ()
      })
      div(flatmate.name, [bottomGroupParent], 
        [Attribute("style", styleCard("#1b2838") ++ "border: 7px dashed #213145;")], 
        [OnClick(UIInteraction(onShowEditMenu))], None()
      )
    }
    def nextTimeDueText(): HtmlElement[Event] / { Model, DataModel } = {
      // val nextTime = nextTimeToBeDone(task)
      val daysUntilDue = daysUntilNextDue(task)
      var text = ""
      if (daysUntilDue > 0) {
        text = "Next in " ++ show(daysUntilDue) ++ " days"
      } else if (daysUntilDue == 0) {
        text = "Due today!"
      } else {
        text = "Overdue by " ++ show(daysUntilDue * -1) ++ " days!"
      }
      div(text, [], [Attribute("style", stylesSection("title"))], [], None())
    }
    def taskInfos(): HtmlElement[Event] / { Model, DataModel } = {
      var showInfosButton = button(svg("arrowdown"), [], 
        [Attribute("style", stylesInfos("infoButton"))], 
        [], None()
      )
      var hideInfosButton = button(svg("arrowup"), [], 
        [Attribute("style", stylesInfos("infoButton") ++ "display: none;")], 
        [], None()
      )
      val infoContainer = viewTaskInfos(task)

      val showInfosNode = showInfosButton.node
      val hideInfosNode = hideInfosButton.node
      val onShowInfos = Action(box {
        showInfosNode.setStyle("display", "none")
        hideInfosNode.setStyle("display", "block")
        infoContainer.node.setStyle("display", "flex")
        ()
      })
      val onHideInfos = Action(box {
        showInfosNode.setStyle("display", "block")
        hideInfosNode.setStyle("display", "none")
        infoContainer.node.setStyle("display", "none")
        ()
      })

      showInfosButton = showInfosButton.addHandlers([OnClick(UIInteraction(onShowInfos))])
      hideInfosButton = hideInfosButton.addHandlers([OnClick(UIInteraction(onHideInfos))])

      val wrapper = div("", [showInfosButton, infoContainer, hideInfosButton], [Attribute("style", styles("wrapper"))], [], None())
      wrapper 
    }


    // Create a card for each flatmate assign to the task an put them in a container
    def taskMenu(): HtmlElement[Event] / { Model, DataModel } = {
      var unassignedFlatmates = empty[Flatmate]()
      flatmates.foreach { flatmate =>
        val isAssigned = task.assignedFlatmates.any { name => name == flatmate.name }
        if (isAssigned == false) { // How do you negate a boolean???
          unassignedFlatmates = unassignedFlatmates.append([flatmate])
        }
        ()
      }

      // First show the assigned flatmates and then the unassigned
      var flatmateCards = empty[HtmlElement[Event]]()
      task.assignedFlatmates.foreach { flatmateName =>
        val flatmate = database.getFlatmateByName(flatmateName)
        val flatmateCard = assignedFlatmateCard(flatmate)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()  
      }
      unassignedFlatmates.foreach { flatmate =>
        val flatmateCard = unassignedFlatmateCard(flatmate)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val title = div(task.name, [], [Attribute("style", stylesSection("title") ++ "font-size: 60px;")], [], None())
      val nextTime = nextTimeDueText()
      val infos = viewTaskInfos(task).viewInfos()
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, nextTime, cardsContainer, infos], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    div("", [taskMenu()], [Attribute("id", task.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], None())
  }
  def viewSingleConsumable(consumable: Consumable): HtmlElement[Event] / { Model, DataModel } = {
    def assignedFlatmateCard(flatmate: Flatmate, count: Int): HtmlElement[Event] / { Model, DataModel } = {
      val counterText = div(show(count), [], [Attribute("style", stylesCardMenu("counterText"))], [], None())
      
      val unassignButton = button("Unassign", [], 
        [Attribute("style", stylesCardMenu("cardButton"))], 
        [OnClick(ConsumableUnassign(consumable.name, flatmate.name))], None()
      )
      val bottomGroup = div("", [unassignButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -15px;")], [], None())
      val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesCardMenu("bottomButtonGroup"))], [], None())

      val incrementButton = button("+", [], 
        [Attribute("style", stylesCardMenu("cardButton") ++ "font-size: 80px; font-weight: bold;")], 
        [OnClick(ConsumableCountIncrement(consumable.name, flatmate.name))], None()
      )
      val topGroup = div("", [incrementButton], [Attribute("style", styles("buttonGroup") ++ "top: -10px;")], [], None())
      val topGroupParent = div("", [topGroup], [Attribute("style", stylesCardMenu("topButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        topGroupParent.node.setStyle("top", "-100px")
        bottomGroupParent.node.setStyle("bottom", "-100px")
        ()
      })
      div(flatmate.name, [counterText, topGroupParent, bottomGroupParent], 
        [Attribute("style", styleCard(flatmate.color))], 
        [OnClick(UIInteraction(onShowEditMenu))], None()
      )
    }
    def unassignedFlatmateCard(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
      val assignButton = button("Assign", [], 
        [Attribute("style", stylesCardMenu("cardButton"))], 
        [OnClick(ConsumableAssign(consumable.name, flatmate.name))], None()
      )
      val bottomGroup = div("", [assignButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -15px;")], [], None())
      val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesCardMenu("bottomButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        bottomGroupParent.node.setStyle("bottom", "-100px")
        ()
      })
      div(flatmate.name, [bottomGroupParent], 
        [Attribute("style", styleCard("#1b2838") ++ "border: 7px dashed #213145;")], 
        [OnClick(UIInteraction(onShowEditMenu))], None()
      )
    }
    def urgencyText(): HtmlElement[Event] / { Model, DataModel } = {
      if (consumable.urgency == 0) {
        div("Not Urgent", [], [Attribute("style", stylesSection("title"))], [], None())
      } else if (consumable.urgency == 1) {
        div("Urgent", [], [Attribute("style", stylesSection("title"))], [], None())
      } else {
        div("Very Urgent", [], [Attribute("style", stylesSection("title"))], [], None())
      }
    }

    // Create a card for each flatmate assign to the consumable an put them in a container
    def consumableMenu(): HtmlElement[Event] / { Model, DataModel } = {
      var unassignedFlatmates = empty[Flatmate]()
      flatmates.foreach { flatmate =>
        val isAssigned = consumable.count.any { case (name, _) => name == flatmate.name }
        if (isAssigned == false) { // How do you negate a boolean???
          unassignedFlatmates = unassignedFlatmates.append([flatmate])
        }
        ()
      }

      // First show the assigned flatmates and then the unassigned
      val sortedCount = sortCount(consumable)
      var flatmateCards = empty[HtmlElement[Event]]()
      sortedCount.foreach { case (flatmateName, count) =>
        val flatmate = database.getFlatmateByName(flatmateName)
        val flatmateCard = assignedFlatmateCard(flatmate, count)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()  
      }
      unassignedFlatmates.foreach { flatmate =>
        val flatmateCard = unassignedFlatmateCard(flatmate)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val title = div(consumable.name, [], [Attribute("style", stylesSection("title") ++ "font-size: 60px;")], [], None())
      val urgency = urgencyText()
      val viewInfos = viewConsumableInfos(consumable).viewInfos()
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, urgency, cardsContainer, viewInfos], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    div("", [consumableMenu()], [Attribute("id", consumable.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], None())
  }
  def viewSingleFlatmate(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
    var textInput = input("", [], 
      [Attribute("style", stylesCardMenu("cardTextInput")), Attribute("value", flatmate.name)],
      [], None()
    )

    val confirmButton = button(svg("confirm"), [],
      [Attribute("style", stylesCardMenu("cardButton"))],
      [OnClick(UpdateFlatmate(flatmate.name, textInput.node))], None()
    ) 
    val cancelButton = button(svg("cancel"), [],
      [Attribute("style", stylesCardMenu("cardButton"))],
      [OnClick(UIReset())], None()
    )
    val bottomGroup = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -20px;")], [], None())
    val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesCardMenu("bottomButtonGroup"))], [], None()) 

    val confirmDeleteButton = button(svg("confirmVertical"), [],
      [Attribute("style", stylesCardMenu("cardButtonVertical"))],
      [OnClick(DeleteFlatmate(flatmate.name))], None()
    )
    val cancelDeleteButton = button(svg("cancelVertical"), [],
      [Attribute("style", stylesCardMenu("cardButtonVertical"))],
      [OnClick(UIReset())], None()
    )
    val rightGroup = div("", [confirmDeleteButton, cancelDeleteButton], [Attribute("style", styles("buttonGroupVertical"))], [], None())
    val rightGroupParent = div("", [rightGroup], [Attribute("style", stylesCardMenu("rightButtonGroup"))], [], None())

    def colorPalette = makeColorPalette(flatmate.color) {global}
    val onColorChange = Action(box {
      bottomGroupParent.node.setStyle("bottom", "-100px")
      
      val color = colorPalette.getColor()
      colorPalette.increment()

      getElementById(flatmate.name ++ "Card").foreach { card => 
        card.setStyle("background-color", color)
        card.setStyle("border", "4px solid " ++ color)
        card.setAttribute("data-value", color)
        ()
      }
      ()
    })
    val onDelete = Action(box {
      rightGroupParent.node.setStyle("right", "-100px")
      ()
    })

    var colorButton = button(svg("color"), [],
      [Attribute("style", stylesCardMenu("cardButton"))],
      [OnClick(UIInteraction(onColorChange))], None()
    )
    val deleteButton = button(svg("delete"), [],
      [Attribute("style", stylesCardMenu("cardButton"))],
      [OnClick(UIInteraction(onDelete))], None()
    )
    val topGroup = div("", [colorButton, deleteButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val topGroupParent = div("", [topGroup], [Attribute("style", stylesCardMenu("topButtonGroup"))], [], None())


    val textInputNode = textInput.node
    val onShowEditMenu = Action(box {
      textInputNode.setAttribute("style", stylesCardMenu("cardTextInputEnabled"))

      topGroupParent.node.setStyle("top", "-100px")
      ()
    })
    val onTextChange = Action(box {
      bottomGroupParent.node.setStyle("bottom", "-100px")
      ()
    })

    textInput = textInput.addHandlers([OnClick(UIInteraction(onShowEditMenu)), OnChange(UIInteraction(onTextChange))])
    val card = div("", [textInput, topGroupParent, bottomGroupParent, rightGroupParent], 
      [Attribute("style", styleCard(flatmate.color)), Attribute("id", flatmate.name ++ "Card"), Attribute("data-value", flatmate.color)], 
      [OnClick(UIInteraction(onShowEditMenu))], None()
    )

    card
  }


  def viewTasks(): HtmlElement[Event] / { Model, DataModel } = {
    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      val tutorialText = """
        <span style="font-size: 35px;">Click on the Add Button to create a new task.</span><br>
        <span style="color: #999;">
        You can set a schedule for each task.<br>
        It is shown when the task have been done the last time, and when it is due next.
        Once a flatmate marks a task as done, they move to the end of the list, and the timer resets. 
        </span>
      """
      val tutorialContainer = viewTutorial(tutorialText)

      // Create the list of tasks
      var taskMenus = empty[HtmlElement[Event]]()
      tasks.foreach { task =>
          val taskMenu = viewSingleTask(task)
          taskMenus = taskMenus.append([taskMenu])
          ()
      }
      val listContainer = div("", taskMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new task
      var addButton = viewAddButton("tasks")
      val addTaskMenu = viewAddTask()

      val addButtonNode = addButton.node
      val addTaskMenuNode = addTaskMenu.node
      val onShowMenu = Action(box {
        addButtonNode.setStyle("display", "none")
        addTaskMenuNode.setStyle("display", "flex")
        ()
      })
      addButton = addButton.addHandlers([OnClick(UIInteraction(onShowMenu))])

      val addContainer = div("", [addButton, addTaskMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [tutorialContainer, listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    
    val taskApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "tasksSettings"), Attribute("style", "display: block")], [], Some(taskApp))
  }
  def viewConsumables(): HtmlElement[Event] / Model = {
    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      val tutorialText = """
        <span style="font-size: 35px;">Click on the Add Button to create a new counter.</span><br>
        <span style="color: #999;">
        This can be used to count how many times a flatmate has bought a shared consumable or has done a irregular task.<br>
        </span>
      """
      val tutorialContainer = viewTutorial(tutorialText)

      // Create the list of consumables
      var consumableMenus = empty[HtmlElement[Event]]()
      consumables.foreach { consumable =>
          val consumableMenu = viewSingleConsumable(consumable)
          consumableMenus = consumableMenus.append([consumableMenu])
          ()
      }
      val listContainer = div("", consumableMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new consumable
      var addButton = viewAddButton("consumables")
      val addConsumableMenu = viewAddConsumable()

      val addButtonNode = addButton.node
      val addConsumableMenuNode = addConsumableMenu.node
      val onShowMenu = Action(box {
        addButtonNode.setStyle("display", "none")
        addConsumableMenuNode.setStyle("display", "flex")
        ()
      })
      addButton = addButton.addHandlers([OnClick(UIInteraction(onShowMenu))])

      val addContainer = div("", [addButton, addConsumableMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [tutorialContainer, listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    val consumableApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "consumablesSettings"), Attribute("style", "display: none;")], [], Some(consumableApp))
  }
  def viewFlatmates(): HtmlElement[Event] / { Model, DataModel } = { 

    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      val tutorialText = """
        <span style="font-size: 35px;">Click on the Add Button to add a new flatmate.</span><br>
        <span style="color: #999;">
        Or click on a flatmate card to edit or delete it.<br>
        New flatmates will be automatically added to all tasks. 
        </span>
      """
      val tutorialContainer = viewTutorial(tutorialText)

      // Create the flatmates menu
      val flatmateNumber = flatmates.size()
      var menuContainer = div("", [], [Attribute("style", "display: none")], [], None())
      if (flatmateNumber > 0) {
        var cards = empty[HtmlElement[Event]]()
        flatmates.foreach { flatmate =>
          val flatmateCard = viewSingleFlatmate(flatmate)
          cards = cards.append([flatmateCard])
          ()
        }
        val cardsContainer = div("", cards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
        val title = div("Flatmates", [], [Attribute("style", stylesSection("title") ++ "font-size: 60px;")], [], None())
        menuContainer = div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())
      }

      // Create the button to add a new flatmate
      var addButton = viewAddButton("flatmates")
      val addFlatmateMenu = viewAddFlatmate()

      val addButtonNode = addButton.node
      val addFlatmateMenuNode = addFlatmateMenu.node
      val onShowMenu = Action(box {
        addButtonNode.setStyle("display", "none")
        addFlatmateMenuNode.setStyle("display", "flex")
        ()
      })
      addButton = addButton.addHandlers([OnClick(UIInteraction(onShowMenu))])
      val addContainer = div("", [addButton, addFlatmateMenu], [Attribute("style", styles("addContainer"))], [], None())

      div("", [tutorialContainer, menuContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }

    val flatmateApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "flatmatesSettings"), Attribute("style", "display: none;")], [], Some(flatmateApp))
  }


  def viewMain(): HtmlElement[Event] / { Model, DataModel } = {
    val navBar = viewNavigationBar()
    val tasksContainer = viewTasks()
    val consumablesContainer = viewConsumables()
    val flatmateContainer = viewFlatmates()
    val container = div("", 
      [navBar, tasksContainer, consumablesContainer, flatmateContainer], 
      [Attribute("style", styles("appContainer"))], [], None()
    )
    container
  }


  // Initialize the root element
  documentBody.setAttribute("style", styles("body"))
  val appDiv = getElementById("app").getOrElse { 
    val newDiv = createElement("div").setAttribute("id", "app")
    documentBody.appendChild(newDiv)
  }
  appDiv.setAttribute("style", styles("app"))

  run(appDiv, Application(
    box { (ev) => ()},
    box { 
      with mainController
      with dataController
      viewMain()
    }
  ))
  ()
}

def main() = {
  addTitle("WG Manager")
  // Download the sql.js library
  addScriptToBody("https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/sql-wasm.js")

  runApp()
  ()
}