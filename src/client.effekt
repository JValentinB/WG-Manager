// Based on Exercise5
module client

import src/utils/dom
import src/utils/UI
import src/utils/misc
import src/database/databaseWeb
import src/database/data
import src/styles
import src/svgIcons

import ref
import string

type Event {
  SwitchSection(section: String);
  ShowAddMenu(section: String);
  HideAddMenu(section: String);

  ShowEditMenu(action: Action);
  HideEditMenu();

  FlatmateChange(action: Action);

  AddTask(name: Node, desc: Node, schedule: Node);
  AddConsumable(name: Node, desc: Node);
  AddFlatmate(input: Node);

  DeleteTask(name: String);
  DeleteConsumable(name: String);
  DeleteFlatmate(name: String);

  UpdateTask(oldName: String, newName: Node, desc: Node, schedule: Node);
  UpdateConsumable(oldName: String, newName: Node, desc: Node);
  UpdateFlatmate(oldName: String, newName: Node);

  TaskDone(taskName: String, flatmateName: String);
  TaskAssign(taskName: String, flatmateName: String);
  TaskUnassign(taskName: String, flatmateName: String);
}

interface Model {
  def switchSection(section: String): Unit
  def showAddMenu(section: String): Unit
  def hideAddMenu(section: String): Unit

  def showEditMenu(action: Action): Unit
  def hideEditMenu(): Unit

  def flatmateChange(action: Action): Unit
}
interface DataModel {
  def addTask(name: Node, desc: Node, schedule: Node): Unit
  def addConsumable(name: Node, desc: Node): Unit
  def addFlatmate(input: Node): Unit

  def deleteTask(name: String): Unit
  def deleteConsumable(name: String): Unit
  def deleteFlatmate(name: String): Unit

  def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node): Unit
  def updateConsumable(oldName: String, newName: Node, desc: Node): Unit
  def updateFlatmate(oldName: String, newName: Node): Unit

  def taskDone(taskName: String, flatmateName: String): Unit
  def taskAssign(taskName: String, flatmateName: String): Unit
  def taskUnassign(taskName: String, flatmateName: String): Unit
}

def run(root: Node, app: Application[Event]): Unit = app match {
  case Application(update, view) =>
    val inbox = ref[List[Event]](Nil())

    def send(ev: Event): Unit = inbox.set(Cons(ev, inbox.get))

    def render(html: HtmlElement[Event]): Node = {
      var node = html.node
      node = node.innerHTML(html.text) // set the text of the node
      // either run the app or render the children
      html.app match {
        case Some(app) => run(node, app)
        case None() => html.children.foreach { child => 
          node.appendChild(child.render)
          ()
        }
      }
      html.attributes.foreach { attr => 
        node.setAttribute(attr.name, attr.value)
        ()
      }
      html.handlers.foreach { handler =>
        handler match {
          case OnClick(ev) => {
            node.onClick(box { send(ev) })
          }
          case OnChange(ev) =>{
            node.onChange(box { send(ev) })
          }
          case OnMouseEnter(ev) => {
            node.onMouseEnter(box { send(ev) })
          }
          case OnMouseLeave(ev) => node.onMouseLeave(box { send(ev) })
        }
        ()
      }
      node
    }

    // renders the app with the current state
    def render(): Unit = {
      val rendered = view().render
      root.clear;
      root.appendChild(rendered);
      ()
    }

    def loop(deadline: IdleDeadline): Unit = {
      val messages = inbox.get.reverse
      inbox.set(Nil())

      if (messages.nonEmpty) {
        messages.foreach { ev =>
          update(ev)
          ev match {
            case AddTask(_, _, _) => render()
            case AddConsumable(_, _) => render()
            case AddFlatmate(_) => render()

            case DeleteTask(_) => render()
            case DeleteConsumable(_) => render()
            case DeleteFlatmate(_) => render()

            case UpdateTask(_, _, _, _) => render()
            case UpdateConsumable(_, _, _) => render()
            case UpdateFlatmate(_, _) => render()

            case TaskDone(_, _) => render()
            case TaskAssign(_, _) => render()
            case TaskUnassign(_, _) => render()

            case HideEditMenu() => render()

            case _ => ()
          }
        }
      }
      requestIdleCallback(box loop)
    }

    render()
    requestIdleCallback(box loop)
}

def dispatch(msg: Event) = {
  msg match {
    case SwitchSection(section) => do switchSection(section)
    case ShowAddMenu(section) => do showAddMenu(section)
    case HideAddMenu(section) => do hideAddMenu(section)

    case ShowEditMenu(action) => do showEditMenu(action)
    case HideEditMenu() => do hideEditMenu()

    case FlatmateChange(action) => do flatmateChange(action)
    case _ => ()
  }
}
def dispatchData(msg: Event) = {
  msg match {
    case AddTask(name, desc, schedule) => do addTask(name, desc, schedule)
    case AddConsumable(name, desc) => do addConsumable(name, desc)
    case AddFlatmate(input) => do addFlatmate(input) 

    case DeleteTask(name) => do deleteTask(name)
    case DeleteConsumable(name) => do deleteConsumable(name)  
    case DeleteFlatmate(name) => do deleteFlatmate(name)

    case UpdateTask(oldName, newName, desc, schedule) => do updateTask(oldName, newName, desc, schedule)
    case UpdateConsumable(oldName, newName, desc) => do updateConsumable(oldName, newName, desc)
    case UpdateFlatmate(oldName, newName) => do updateFlatmate(oldName, newName)

    case TaskDone(taskName, flatmateName) => do taskDone(taskName, flatmateName)
    case TaskAssign(taskName, flatmateName) => do taskAssign(taskName, flatmateName)
    case TaskUnassign(taskName, flatmateName) => do taskUnassign(taskName, flatmateName)
    case _ => ()
  }
}

def mainController[R] { prog: => R / Model }: R =
  try { prog() }
  with Model {
    def switchSection(section: String) = {
      ["tasks", "consumables", "flatmates"].foreach { id =>
        getElementById(id ++ "Settings").foreach { node =>
          node.toggleDisplay(section == id)
        }

        getElementById(id ++ "Button").foreach { node =>
          if (section == id) {
            node.setAttribute("style", stylesNavBar("navButtonActive"))
          } else {
            node.setAttribute("style", stylesNavBar("navButtonInactive"))
          }
          ()
        }
        ()
      }
      resume(())
    }

    def showAddMenu(section: String) = {
      toggleAddMenu(section, true)
      resume(())
    }
    def hideAddMenu(section: String) = {
      toggleAddMenu(section, false)
      resume(())
    }

    def showEditMenu(action: Action) = action match {
      case Action(f) => {
        f()
        resume(())
      }
    }
    def hideEditMenu() = {
      // simply resets the application
      resume(())
    }

    def flatmateChange(action: Action) = action match {
      case Action(f) => {
        f()
        resume(())
      }
    }
}


def runApp(): Unit = {
  // request the database file 
  var database in global = fetchDatabase("/database")
  var flatmates in global = database.getFlatmates()
  var tasks in global = database.getTasks()
  var consumables in global = database.getConsumables()

  def updateDatabase(): Unit = {
    database = fetchDatabase("/database")
  }
  def updateDataCategoryFromDatabase(category: String): Unit = {
    category match {
      case "flatmates" => flatmates = database.getFlatmates()
      case "tasks" => tasks = database.getTasks()
      case "consumables" => consumables = database.getConsumables()
      case _ => ()
    }
  }

  def dataController[R] { prog: => R / DataModel }: R = {
    try { prog() }
    with DataModel {
      def addTask(name: Node, desc: Node, schedule: Node) = {
        val taskName = name.getValue()
        val taskDesc = desc.getValue()
        val taskSchedule = schedule.getValue()
        if (taskName != "" && taskDesc != "" && taskSchedule != "") {
          val response = post("/addTask", "{\"name\":\"" ++ taskName ++ "\",\"description\":\"" ++ taskDesc ++ "\",\"schedule\":" ++ taskSchedule ++ "}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("tasks")
          }
        } else {
          alert("Please enter a name, description and schedule")
        }
        resume(())
      }
      def addConsumable(name: Node, desc: Node) = {
        val consumableName = name.getValue()
        val consumableDesc = desc.getValue()
        if (consumableName != "" && consumableDesc != "") {
          val response = post("/addConsumable", "{\"name\":\"" ++ consumableName ++ "\",\"description\":\"" ++ consumableDesc ++ "\"}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("consumables")
          }
        } else {
          alert("Please enter a name and description")
        }
        resume(())
      }
      def addFlatmate(input: Node) = {
        val name = input.getValue()
        if (name != "") {
          val response = post("/addFlatmate", "{\"name\":\"" ++ name ++ "\"}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("flatmates")
          }
        } else {
          alert("Please enter a name")
        }
        resume(())
      }
      def deleteTask(name: String) = {
        val response = post("/deleteTask", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("tasks")
        resume(())
      }
      def deleteConsumable(name: String) = {
        val response = post("/deleteConsumable", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("consumables")
        resume(())
      }
      def deleteFlatmate(name: String) = {
        val response = post("/deleteFlatmate", "{\"name\":\"" ++ name ++ "\"}")
        updateDatabase()
        updateDataCategoryFromDatabase("flatmates")
        resume(())
      }

      def updateTask(oldName: String, newName: Node, desc: Node, schedule: Node) = {
        resume(())
      }
      def updateConsumable(oldName: String, newName: Node, desc: Node) = {
        resume(())
      }
      def updateFlatmate(oldName: String, newName: Node) = {
        val name = newName.getValue()
        
        if (name == "") {
          alert("Please enter a name")
        } else {
          var color = ""
          getElementById(oldName ++ "Card").foreach { card => 
            card.setAttribute("id", name ++ "Card")

            color = card.getAttribute("data-value")
            ()
          }
          val response = post("/updateFlatmate", "{\"oldName\":\"" ++ oldName ++ "\",\"newName\":\"" ++ name ++ "\",\"color\":\"" ++ color ++ "\"}")
          handleServerResponse(response) {
            updateDatabase()
            updateDataCategoryFromDatabase("flatmates")
          }
        }
        resume(())
      }

      def taskDone(taskName: String, flatmateName: String) = {
        val response = post("/taskDone", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }
      def taskAssign(taskName: String, flatmateName: String) = {
        val response = post("/taskAssign", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }
      def taskUnassign(taskName: String, flatmateName: String) = {
        val response = post("/taskUnassign", "{\"taskName\":\"" ++ taskName ++ "\",\"flatmateName\":\"" ++ flatmateName ++ "\"}")
        handleServerResponse(response) {
          updateDatabase()
          updateDataCategoryFromDatabase("tasks")
        }
        resume(())
      }
    }
  }


  def viewNavigationBar(): HtmlElement[Event] / Model = {
    val tasksButton = button(svg("tasks"), [], 
      [Attribute("style", stylesNavBar("navButtonActive")), Attribute("id", "tasksButton")], 
      [OnClick(SwitchSection("tasks"))], None()
    )
    val consumButton = button(svg("consumables"), [], 
      [Attribute("style", stylesNavBar("navButtonInactive")), Attribute("id", "consumablesButton")], 
      [OnClick(SwitchSection("consumables"))], None()
    )
    val flatmatesButton = button(svg("flatmates"), [], 
      [Attribute("style", stylesNavBar("navButtonInactive")), Attribute("id", "flatmatesButton")], 
      [OnClick(SwitchSection("flatmates"))], None()
    )
    val wrapper = div("", [tasksButton, consumButton, flatmatesButton], [Attribute("style", styles("wrapper"))], [], None())

    val navBarApp = Application[Event](
      box { (ev) => 
        with mainController
        ev.dispatch()
      },
      box { 
        with mainController
        wrapper
      }
    )
    val navBar = div("", 
      [], [Attribute("style", stylesNavBar("navBar"))], 
      [], Some(navBarApp))
    navBar
  }
  def viewAddButton(section: String): HtmlElement[Event] / Model = {
    val plus = div("+", [], [Attribute("style", "position: absolute; top: -25%; left: 47%;")], [], None())
    val addButton = button("", [plus], 
      [Attribute("style", styles("addButton")), Attribute("id", section ++ "AddButton")], 
      [OnClick(ShowAddMenu(section))], None()
    )
    addButton
  }


  def viewAddTask(): HtmlElement[Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task description")], 
      [], None()
    )
    val numberAttributes = [Attribute("type", "number"), Attribute("min", "1"), Attribute("max", "365")]
    val scheduleInput = input("", [], 
      numberAttributes.append([Attribute("style", styles("textInput")), Attribute("placeholder", "Enter task schedule in days")]), 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddTask(nameInput.node, descriptionInput.node, scheduleInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("tasks"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [nameInput, descriptionInput, scheduleInput, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "tasksAddMenu")],
      [], None()
    )
    container
  }
  def viewAddConsumable(): HtmlElement[Event] / { Model, DataModel } = {
    val nameInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable name")], 
      [], None()
    )
    val descriptionInput = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter consumable description")], 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddConsumable(nameInput.node, descriptionInput.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("consumables"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [nameInput, descriptionInput, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "consumablesAddMenu")],
      [], None()
    )
    container
  }
  def viewAddFlatmate(): HtmlElement[Event] / { Model, DataModel } = {
    val input = input("", [], 
      [Attribute("style", styles("textInput")), Attribute("placeholder", "Enter flatmate name")], 
      [], None()
    )

    val confirmButton = button("Add", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(AddFlatmate(input.node))], None()
    )
    val cancelButton = button("Cancel", [], 
      [Attribute("style", styles("groupButton"))], 
      [OnClick(HideAddMenu("flatmates"))], None()
    )
    val buttonContainer = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val container = div("", 
      [input, buttonContainer], 
      [Attribute("style", styles("addMenu")), Attribute("id", "flatmatesAddMenu")],
      [], None()
    )
    container
  }


  def viewEditTask(task: Task): HtmlElement[Event] / { Model, DataModel } = {
    div(task.name, [], [Attribute("style", stylesSection("title"))], [], None())
  }
  def viewEditConsumable(consumable: Consumable): HtmlElement[Event] / { Model, DataModel } = {
    div(consumable.name, [], [Attribute("style", stylesSection("title"))], [], None())
  }

  def viewSingleTask(task: Task): HtmlElement[Event] / { Model, DataModel } = {
    def assignedFlatmateCard(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
      val taskDoneButton = button("Task Done", [], 
        [Attribute("style", stylesSection("cardButton"))], 
        [OnClick(TaskDone(task.name, flatmate.name))], None()
      )
      val bottomGroup = div("", [taskDoneButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -15px;")], [], None())
      val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesSection("bottomButtonGroup"))], [], None())

      val unassignButton = button("Unassign", [], 
        [Attribute("style", stylesSection("cardButton"))], 
        [OnClick(TaskUnassign(task.name, flatmate.name))], None()
      )
      val topGroup = div("", [unassignButton], [Attribute("style", styles("buttonGroup") ++ "top: 0;")], [], None())
      val topGroupParent = div("", [topGroup], [Attribute("style", stylesSection("topButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        topGroupParent.node.setStyle("top", "-100px")
        bottomGroupParent.node.setStyle("bottom", "-100px")
        ()
      })
      div(flatmate.name, [topGroupParent, bottomGroupParent], 
        [Attribute("style", styleCard(flatmate.color))], 
        [OnClick(ShowEditMenu(onShowEditMenu))], None()
      )
    }
    def unassignedFlatmateCard(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
      val assignButton = button("Assign", [], 
        [Attribute("style", stylesSection("cardButton"))], 
        [OnClick(TaskAssign(task.name, flatmate.name))], None()
      )
      val topGroup = div("", [assignButton], [Attribute("style", styles("buttonGroup") ++ "top: 0;")], [], None())
      val topGroupParent = div("", [topGroup], [Attribute("style", stylesSection("topButtonGroup"))], [], None())

      val onShowEditMenu = Action(box {
        topGroupParent.node.setStyle("top", "-100px")
        ()
      })
      div(flatmate.name, [topGroupParent], 
        [Attribute("style", styleCard("#1b2838") ++ "border: 7px dashed #213145;")], 
        [OnClick(ShowEditMenu(onShowEditMenu))], None()
      )
    }

    // Create a card for each flatmate assign to the task an put them in a container
    def taskMenu(): HtmlElement[Event] / { Model, DataModel } = {
      var flatmates = database.getFlatmates()
      var unassignedFlatmates = empty[Flatmate]()
      flatmates.foreach { flatmate =>
        val isAssigned = task.assignedFlatmates.any { name => name == flatmate.name }
        if (isAssigned == false) { // How do you negate a boolean???
          unassignedFlatmates = unassignedFlatmates.append([flatmate])
        }
        ()
      }

      var flatmateCards = empty[HtmlElement[Event]]()
      task.assignedFlatmates.foreach { flatmateName =>
        val flatmate = database.getFlatmateByName(flatmateName)
        val flatmateCard = assignedFlatmateCard(flatmate)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()  
      }
      unassignedFlatmates.foreach { flatmate =>
        val flatmateCard = unassignedFlatmateCard(flatmate)
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val nextTime = nextTimeToBeDone(task)
      val title = div(task.name++ " - Next on " ++ nextTime, [], [Attribute("style", stylesSection("title"))], [], None())
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    div("", [taskMenu()], [Attribute("id", task.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], None())
  }
  def viewSingleConsumable(consumable: Consumable): HtmlElement[Event] / { Model, DataModel } = {
    // Create a card for each flatmate assign to the task an put them in a container
    def consumableMenu(): HtmlElement[Event] / { Model, DataModel } = {
      var flatmateCards = empty[HtmlElement[Event]]()
      consumable.count.foreach { case (name, count) =>
        val flatmate = database.getFlatmateByName(name)

        val flatmateCard = div(name, [], [Attribute("style", styleCard(flatmate.color))], [], None())
        flatmateCards = flatmateCards.append([flatmateCard])
        ()
      }

      val title = div(consumable.name, [], [Attribute("style", stylesSection("title"))], [], None())
      val cardsContainer = div("", flatmateCards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())
    }

    val consumableApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        consumableMenu()
      }
    )
    div("", [], [Attribute("id", consumable.name ++ "Settings"), Attribute("style", "display: block; width: 100%;")], [], Some(consumableApp))
  }
  def viewSingleFlatmate(flatmate: Flatmate): HtmlElement[Event] / { Model, DataModel } = {
    var textInput = input("", [], 
      [Attribute("style", stylesSection("cardTextInput")), Attribute("value", flatmate.name)],
      [], None()
    )

    val confirmButton = button(svg("confirm"), [],
      [Attribute("style", stylesSection("cardButton"))],
      [OnClick(UpdateFlatmate(flatmate.name, textInput.node))], None()
    ) 
    val cancelButton = button(svg("cancel"), [],
      [Attribute("style", stylesSection("cardButton"))],
      [OnClick(HideEditMenu())], None()
    )
    val bottomGroup = div("", [confirmButton, cancelButton], [Attribute("style", styles("buttonGroup") ++ "bottom: -20px;")], [], None())
    val bottomGroupParent = div("", [bottomGroup], [Attribute("style", stylesSection("bottomButtonGroup"))], [], None()) 

    val confirmDeleteButton = button(svg("confirmVertical"), [],
      [Attribute("style", stylesSection("cardButtonVertical"))],
      [OnClick(DeleteFlatmate(flatmate.name))], None()
    )
    val cancelDeleteButton = button(svg("cancelVertical"), [],
      [Attribute("style", stylesSection("cardButtonVertical"))],
      [OnClick(HideEditMenu())], None()
    )
    val rightGroup = div("", [confirmDeleteButton, cancelDeleteButton], [Attribute("style", styles("buttonGroupVertical"))], [], None())
    val rightGroupParent = div("", [rightGroup], [Attribute("style", stylesSection("rightButtonGroup"))], [], None())


    val onColorChange = Action(box {
      bottomGroupParent.node.setStyle("bottom", "-100px")
      
      val color = colorPalette()
      getElementById(flatmate.name ++ "Card").foreach { card => 
        card.setStyle("background-color", color)
        card.setStyle("outline", "4px solid " ++ color)
        card.setAttribute("data-value", color)
        ()
      }
      ()
    })
    val onDelete = Action(box {
      rightGroupParent.node.setStyle("right", "-100px")
      ()
    })

    var colorButton = button(svg("color"), [],
      [Attribute("style", stylesSection("cardButton"))],
      [OnClick(FlatmateChange(onColorChange))], None()
    )
    val deleteButton = button(svg("delete"), [],
      [Attribute("style", stylesSection("cardButton"))],
      [OnClick(FlatmateChange(onDelete))], None()
    )
    val topGroup = div("", [colorButton, deleteButton], [Attribute("style", styles("buttonGroup"))], [], None())
    val topGroupParent = div("", [topGroup], [Attribute("style", stylesSection("topButtonGroup"))], [], None())


    val textInputNode = textInput.node
    val onShowEditMenu = Action(box {
      textInputNode.setAttribute("style", stylesSection("cardTextInputEnabled"))

      topGroupParent.node.setStyle("top", "-100px")
      ()
    })
    val onTextChange = Action(box {
      bottomGroupParent.node.setStyle("bottom", "-100px")
      ()
    })

    textInput = textInput.addHandlers([OnClick(ShowEditMenu(onShowEditMenu)), OnChange(FlatmateChange(onTextChange))])
    val card = div("", [textInput, topGroupParent, bottomGroupParent, rightGroupParent], 
      [Attribute("style", styleCard(flatmate.color)), Attribute("id", flatmate.name ++ "Card"), Attribute("data-value", flatmate.color)], 
      [OnClick(ShowEditMenu(onShowEditMenu))], None()
    )

    card
  }


  def viewTasks(): HtmlElement[Event] / { Model, DataModel } = {
    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      var taskMenus = empty[HtmlElement[Event]]()
      tasks.foreach { task =>
          val taskMenu = viewSingleTask(task)
          taskMenus = taskMenus.append([taskMenu])
          ()
      }
      val listContainer = div("", taskMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new task
      val addButton = viewAddButton("tasks")
      val addTaskMenu = viewAddTask()
      val addContainer = div("", [addButton, addTaskMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    
    val taskApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "tasksSettings"), Attribute("style", "display: block")], [], Some(taskApp))
  }
  def viewConsumables(): HtmlElement[Event] / Model = {
    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      var consumableMenus = empty[HtmlElement[Event]]()
      consumables.foreach { consumable =>
          val consumableMenu = viewSingleConsumable(consumable)
          consumableMenus = consumableMenus.append([consumableMenu])
          ()
      }
      val listContainer = div("", consumableMenus, [Attribute("style", stylesSection("listContainer"))], [], None())

      // Create the button to add a new consumable
      val addButton = viewAddButton("consumables")
      val addConsumableMenu = viewAddConsumable()
      val addContainer = div("", [addButton, addConsumableMenu], [Attribute("style", styles("addContainer"))], [], None())
      
      div("", [listContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }
    
    val consumableApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "consumablesSettings"), Attribute("style", "display: none;")], [], Some(consumableApp))
  }
  def viewFlatmates(): HtmlElement[Event] / { Model, DataModel } = { 

    def menu(): HtmlElement[Event] / { Model, DataModel } = {
      var cards = empty[HtmlElement[Event]]()
      var editMenus = empty[HtmlElement[Event]]()
      flatmates.foreach { flatmate =>
        val flatmateCard = viewSingleFlatmate(flatmate)
        cards = cards.append([flatmateCard])
        // val editFlatmate = viewEditFlatmate(flatmate)
        // editMenus = editMenus.append([editFlatmate])
        ()
      }
      val cardsContainer = div("", cards, [Attribute("style", stylesSection("cardsContainer"))], [], None())
      val title = div("Flatmates", [], [Attribute("style", stylesSection("title"))], [], None())
      val menuContainer = div("", [title, cardsContainer], [Attribute("style", stylesSection("entryContainer"))], [], None())

      val editContainer = div("", editMenus, [Attribute("style", "display: block; width: 100%;"), Attribute("id", "flatmateEdit")], [], None())

      val addButton = viewAddButton("flatmates")
      val addFlatmateMenu = viewAddFlatmate()
      val addContainer = div("", [addButton, addFlatmateMenu], [Attribute("style", styles("addContainer"))], [], None())

      div("", [menuContainer, editContainer, addContainer], [Attribute("style", stylesSection("listContainer"))], [], None())
    }

    val flatmateApp = Application[Event](
      box { (ev) => 
        with mainController
        with dataController
        ev.dispatch()
        ev.dispatchData()
      },
      box { 
        with mainController
        with dataController
        menu()
      }
    )
    div("", [], [Attribute("id", "flatmatesSettings"), Attribute("style", "display: none;")], [], Some(flatmateApp))
  }


  def viewMain(): HtmlElement[Event] / { Model, DataModel } = {
    val navBar = viewNavigationBar()
    val tasksContainer = viewTasks()
    val consumablesContainer = viewConsumables()
    val flatmateContainer = viewFlatmates()
    val container = div("", 
      [navBar, tasksContainer, consumablesContainer, flatmateContainer], 
      [Attribute("style", styles("appContainer"))], [], None()
    )
    container
  }



  documentBody.setAttribute("style", styles("body"))
  val appDiv = getElementById("app").getOrElse { 
    val newDiv = createElement("div").setAttribute("id", "app")
    documentBody.appendChild(newDiv)
  }
  appDiv.setAttribute("style", styles("app"))

  run(appDiv, Application(
    box { (ev) => ()},
    box { 
      with mainController
      with dataController
      viewMain()
    }
  ))
  ()
}

def main() = {
  addTitle("WG Manager")
  // Download the sql.js library
  addScriptToBody("https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/sql-wasm.js")

  runApp()
  ()
}